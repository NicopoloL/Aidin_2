<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>М.Ю. Павлов, А.В. Боднар - Чистый код как концепция развития программного обеспечения: теория и применение в компонентно-ориентированном программировании</title>
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
    
</head>

<body>
    <header>
        <a href="../index.html">вернуться в раздел "Научные труды"</a>
    </header>

    <article id="artic">
        <header>
            <p>УДК 004.42</p>
            <h1>Чистый код как концепция развития программного обеспечения: теория и применение в компонентно-ориентированном программировании</h1>
            <h2>Павлов М.Ю., Боднар А.В.</h2>
            <h3>Донецкий национальный технический университет, г. Донецк</h3>
            <h3>кафедра программной инженерии</h3>
            <h3>E-mail: <a href="mailto:vigototheroad@mail.ru">vigototheroad@mail.ru</a></h3>
        </header>

        <main>
           <section>
                <div class="annotation">
                    <p>Статья рассматривает понятие чистого кода и его роль в разработке ПО. Анализируются отличия чистого и «грязного» кода и их влияние на проектирование. Особое внимание уделено компонентно-ориентированному программированию как способу эффективного применения принципов чистого кода. Подход к чистому коду как к философии развития программного продукта позволяет достичь оптимального баланса между качеством архитектуры и практическими требованиями разработки.</p>
                </div>
            </section>

           <section>
                <h2>Введение</h2>
                <p>Что делает код «чистым»? В программировании часто обсуждают принципы хорошего стиля, архитектурной чистоты и читаемости кода. Но где проходит грань между чистым и грязным кодом? Можно ли считать плохо структурированный, но работающий код действительно «грязным»?</p>
                <p>В своей книге «Чистый код» Роберт Мартин утверждает: «Умение писать чистый код – тяжёлый труд. Оно не ограничивается знанием паттернов и принципов. Над кодом необходимо попотеть. Необходимо пытаться и терпеть неудачи» <a href="#lit1">[1]</a>.</p>
                <p>Так что же такое «чистый» код и каким критериям он должен соответствовать? Код, который не соответствует эти критериям, автоматически становится плохим? Важно понимать, что в реальных условиях программирования иногда приходится отклоняться от полного соответствия стандартам в угоду скорости разработки, требованиям бизнеса или ограничениям ресурсов.</p>
                <p>В этой статье рассматривается, чем отличается чистый код от «грязного», в каких ситуациях «грязный» код может быть оправдан и почему фанатичное следование правилам может привести к обратному эффекту.</p>
            </section>


            <section>
                <h2>Чистый Код</h2>
                <p>Стоит уточнить, что само выражение «чистый код» имеет множество смыслов и трактовок, но в рамках данной работы будет выведено общее определение, которое наилучшим образом отражает его идею. В книге Роберта Мартина нет чёткого определения – вместо этого автор описывает отношение ведущих разработчиков к чистому коду и то, как, по их мнению, он должен выглядеть.</p>
                <p>Ниже приведены некоторые цитаты из данной книги <a href="#lit1">[1]</a>:</p>
                
                <ul class="ul_nobullet">
                    <li>«Вы работаете с чистым кодом, если каждая функция делает примерно то, что вы ожидали. Код можно назвать красивым, если у вас также создается впечатление, что язык был создан специально для этой задачи», – Уорд Каннингем.</li>
                    <li>«Я мог бы перечислить все признаки, присущие чистому коду, но существует один важнейший признак, из которого следуют все остальные. Чистый код всегда выглядит так, словно его автор над ним тщательно потрудился», – Майкл Физерс <a href="#lit1">[1]</a>.</li>
                    <li>«Сокращение дублирования, высокая выразительность и раннее построение простых абстракций. Все это составляет чистый код в моем понимании», – Рон Джеффрис <a href="#lit1">[1]</a>.</li>
                    <p>Самая лаконичная и при том информативная цитата принадлежит Бьёрну Страуструпу:</p>
                    <li>«Чистый код – это код, который легко читать и улучшать» <a href="#lit1">[1]</a>.</li>
                </ul>

                <p>Про способы написания чистого кода, изложенные в книге, Роберт Мартин говорит следующее:</p>
                <p>«Мы излагаем свои мнения в виде беспрекословных истин и не извиняемся за свою категоричность. Для нас, на данном моменте наших карьер, они являются беспрекословными истинами» <a href="#lit1">[1]</a>.</p>
                <p>Хотя Роберт Мартин не даёт прямого определения чистому коду, сама книга описывает критерии, которым следуют как сам Мартин, так и разработчики, которых он приводит в пример. Тем самым он описывает следующие характеристики чистого кода:</p>
                
                <ul class="ul_dash">
                    <li>понятность;</li>
                    <li>лаконичность;</li>
                    <li>логичность;</li>
                    <li>работа на одном уровне абстракции;</li>
                    <li>модульность;</li>
                    <li>легкость в поддерживании;</li>
                    <li>тестируемость.</li>
                </ul>

                <p>Эти принципы прослеживаются в конце книги, в списке эвристических правил и «запахов» кода. Под «запахами» подразумеваются опыт и интуиция программиста, говорящие ему о том, что с кодом что-то не так. Поскольку эвристические правила зависят от конкретного программиста и его видения кода, то их существует огромное множество.</p>
                <p>Важным является то, что вышеописанные идеи нашли отражение во многих подходах к разработке программного обеспечения. К примеру, в объектно-ориентированном программировании (ООП) принципы инкапсуляции и полиморфизма помогают писать расширяемый код, при этом не разрушая изначальную структуру и создавая управляемую конструкцию. В компонентно-ориентированном программировании (КОП) акцент делается на гибкость модулей. В нём реализация выходит за рамки конкретного компонента, позволяя взаимодействовать с любыми объектами, имеющими определенный модуль, через «системный» компонент, что так же поддерживает ранее описываемую идею.</p>
                <p>Все вышеописанное позволяет вывести следующее определение чистого кода:</p>
                <p>Чистый код – это не просто стиль написания, а разумный подход к разработке. Это код, который выполняет свою задачу и не мешает улучшению продукта.</p>
            </section>

            <section>
                <h2>Грязный код</h2>
                <p>Грязный код является противоположностью чистого. Если идти от обратного, то у такого кода должна отсутствовать хотя бы одна из характеристик чистого кода. Возникает вопрос: достаточно ли отсутствия одного критерия, чтобы код считался грязным, или он должен не соответствовать всем критериям одновременно? Как упоминалось в книге, отсутствие определенных качеств в коде может привести к проблемам. Например, неправильное именование переменной вызывает вопросы о её предназначении. Это и есть первопричина появления «не чистого» кода. </p>
                <p>Дать прямое определение «грязному» коду довольно сложно. Можно ли считать весь код, который не соответствует критериям чистого, грязным? Сложности с определением связаны с отсутствием чистых критериев. Однако, здесь возможны два подхода.</p>
                <p>Первый подход заключается в отрицании чистого кода: любой код, не соответствующий его критериям, автоматически считается грязным.</p>
                <p>Второй подход предполагает описание собственного понимания грязного кода и определение границы, за которой «грязь» начинает вредить.</p>
            </section>

            <section>
                <h2>Грязный код как отрицание чистого кода</h2>
                <p>Со знанием критериев чистого кода становится возможным сформулировать то, чем является «грязный» код:</p>
                
                <ul class="ul_dash">
                    <li>неочевидность (использование непонятных имен переменных и функций, слишком длинные или вложенные конструкции, затрудняющие восприятие, применение «магических чисел» вместо осмысленных констант);</li>
                    <li>избыточность (дублирование кода, написание избыточных проверок, которые уже предусмотрены языком, использование ненужных переменных и классов, усложняющих структуру);</li>
                    <li>хаотичность (отсутствие четкой структуры, использование разных стилей кодирования в одном файле, изменение переменных в разных частях кода, что затрудняет отслеживание их состояния);</li>
                    <li>смешение абстракций (одновременная работа с абстрактными и конкретными деталями);</li>
                    <li>монолитность (весь код сосредоточен в одном огромном классе без разделения на модули, один метод выполняет несколько задач вместо их делегирования, отсутствие четких границ ответственности между частями кода);</li>
                    <li>хрупкость (любое изменение ломает другие части системы, код зависит от множества несвязанных модулей, функции и классы разрастаются, содержат десятки параметров);</li>
                    <li>плохая тестируемость (многие функции имеют неочевидные входные и выходные данные или выполняют дополнительные действия, влияющие не только на результат).</li>
                </ul>

                <p>Если хотя бы один из этих пунктов применим к коду, его можно считать «грязным».</p>
                <p>Однако, имеется нюанс: код не всегда бывает идеальным. Даже с учетом приведенного определения сложно представить код, который бы соответствовал всем требованиям одновременно.</p>
                <p>Например, оптимизированный алгоритм может выглядеть запутанно, но он необходим для повышения производительности. Или в коде могут быть реализованы сложные взаимодействия, но при этом входные и выходные данные сами по себе просты.</p>
                <p>Таким образом, в рамках этого подхода практически любой код можно считать «грязным».</p>
            </section>

           <section>
                <h2>Когда грязный код действительно вреден</h2>
                <p>Когда код можно считать «грязным»? Логично предположить, что решать проблему стоит тогда, когда она действительно начинает негативно влиять на разработку.</p>
            
                <p>Когда код является приемлемым?</p>
                <ul class="ul_dash">
                    <li>он локализован и не разрастается по всей системе;</li>
                    <li>он выполняет простую логику без неоднозначных выводов;</li>
                    <li>его легко адаптировать;</li>
                    <li>он не создает лишние зависимости;</li>
                    <li>он оправдан скоростью работы или разработки;</li>
                    <li>он временный и будет исправлен позже.</li>
                </ul>

                <p>Когда грязный код начинает вредить?</p>
                <ul class="ul_dash">
                    <li>его сложно понять и реализовать;</li>
                    <li>он провоцирует цепную реакцию багов при изменении;</li>
                    <li>он требует изменение базовой логики при дальнейшей разработке;</li>
                    <li>его операции ведут к неявным входным и выходным данным.</li>
                </ul>

                <p>Таким образом, граница между неидеальным, но рабочим кодом и по-настоящему вредным кодом проходит там, где он начинает мешать развитию и поддержке продукта. Если код замедляет разработку, вносит хаос и увеличивает вероятность ошибок – это уже не компромисс, а проблема.</p>
                <p>Второй подход кажется более практичным, особенно в условиях реальной разработки. Он несет в себе простую идею: грязный код становится проблемой только тогда, когда начинает негативно влиять на проект. Конечно, в некоторых случаях частные правила важнее глобальных, и попытка внедрить идеальные стандарты там, где они не нужны, может только навредить, запутывая логику и усложняя ранее выполненную работу.</p>
            </section>

            <section>
                <h2>Использование чистого кода в КОП</h2>
                <p>Понимание принципов чистого кода позволяет эффективно применять их в компонентно-ориентированном подходе. В данном разделе рассматривается, как принципы чистого кода используются в этой парадигме, каким образом их соблюдение упрощает разработку, а также какие базовые особенности написания кода в рамках КОП необходимо учитывать. Слепое заимствование практик чистого кода оказывается недостаточным – их требуется адаптировать к специфике КОП и особенностям разработки для обеспечения эффективности и гибкости создаваемых систем.</p>
                <p>КОП активно опирается на принцип «композиция вместо наследования». Вместо построения сложных иерархий классов, где поведение объектов определяется через наследование, КОП формирует объекты путём комбинирования независимых компонентов, каждый из которых отвечает за отдельную функциональность. Это повышает гибкость системы, позволяя без значительных затрат добавлять, удалять или изменять поведение объектов. Наследование, напротив, часто приводит к жёстким связям между классами, что затрудняет модификацию системы. Например, в RPG-системе, если персонаж наследует базовый класс Character, а затем создаются подклассы Warrior, Mage и другие, изменение базового класса способно нарушить корректную работу всех производных классов. Композиция позволяет динамически добавлять компоненты по мере необходимости, что значительно упрощает настройку объектов.</p>
                <p>Ещё одной важной характеристикой КОП является возможность добавления, удаления или изменения компонентов во время выполнения программы. Это обеспечивает адаптивность системы к изменяющимся условиям без необходимости модификации исходного кода или перекомпиляции проекта. Например, в RPG-проекте персонаж может получить новую способность в процессе выполнения квеста, что повышает интерактивность игрового мира.</p>
                <p>КОП часто применяет системы, координирующие взаимодействие групп компонентов. Вместо прямого взаимодействия между компонентами данные обрабатываются системами, которые обновляют их состояние. Такой подход характерен для архитектуры Entity-Component-System (ECS), одной из популярных реализаций КОП. В ECS компоненты представляют собой структуры данных, а системы реализуют прикладную логику, что снижает связанность и способствует повышению производительности.</p>
                <p>КОП также поощряет декларативный подход, при котором поведение и свойства компонентов определяются через данные, а не через жёстко закодированную логику. Это реализуется посредством сериализации данных, например через форматы JSON, XML или настройки редакторов игровых движков, таких как Unity. Такой подход упрощает процесс настройки компонентов дизайнерами без необходимости внесения изменений в код. Несмотря на возможное противоречие с принципом самодокументируемости кода, в Unity использование атрибутов, таких как [SerializeField], позволяет создавать наглядные интерфейсы редактора и задавать связи между компонентами без нарушения читаемости.</p>
                <p>Компоненты в КОП должны быть максимально автономными, то есть их поведение не должно зависеть от состояния других компонентов, за исключением явно определённых взаимодействий, например, через события или системы. Автономность обеспечивает переиспользуемость компонентов в различных контекстах без необходимости их модификации. Например, компонент HealthComponent может использоваться как для игроков, так и для NPC или разрушаемых объектов.</p>
                <p>Принцип читаемости ярко выражен в КОП, поскольку каждый компонент отвечает за строго определённую функциональность. Названия компонентов и их методов должны быть интуитивно понятными. Например, вместо абстрактного Component1 предпочтительнее использовать наименования вроде PlayerMovementComponent или InventoryComponent, что упрощает восприятие кода. Лаконичность достигается за счёт того, что каждый компонент описывает только необходимые характеристики, используемые системами для реализации функциональности, минимизируя избыточный код и повышая управляемость компонентов.</p>
                <p>Принцип единой ответственности в КОП реализуется элегантно: каждый компонент выполняет только одну функцию. Например, в RPG-системе HealthComponent управляет здоровьем персонажа, а InventoryComponent – его предметами. Это предотвращает создание так называемых «божественных объектов», объединяющих множество функций, что увеличивает сложность системы и снижает её гибкость. Зависимости между компонентами минимизируются посредством обмена данными через события, сообщения или интерфейсы, а не через прямые ссылки. Это снижает связанность и повышает модульность системы. Например, компонент атаки может генерировать событие OnAttack, обрабатываемое компонентом здоровья без знания о его внутреннем устройстве.</p>
                <p>Для устранения дублирования кода в КОП применяются базовые компоненты или утилитные классы. Например, если несколько компонентов используют событийную модель, целесообразно создать общий EventManager, который централизованно управляет событиями, устраняя необходимость повторного написания однотипного кода.</p>
            </section>

            <section>
                <h2>Чистый код в КОП: синтез авторских подходов</h2>
                <p>Понимание чистого кода в компонентно-ориентированном программировании не может ограничиваться только практическими приёмами. Для полноценного применения этой концепции необходимо учитывать теоретические и методологические подходы, выработанные ведущими исследователями в области программной инженерии. В данной главе рассмотрены взгляды авторов, оказавших значительное влияние на формирование современной культуры разработки, а также проведена интерпретация их идей в контексте КОП.</p>
                <p>В книге «Совершенный код» С. Макконнелл подчёркивает, что читаемость, локализация изменений и снижение когнитивной нагрузки – ключевые признаки качественного кода <a href="#lit2">[2]</a>. Эти принципы непосредственно применимы к КОП, где каждый компонент реализует узкоспециализированную функцию, а значит, должен быть предельно понятным и изолированным.</p>
                <p>М. Фаулер в книге «Рефакторинг» рассматривает архитектурную чистоту как результат регулярной реорганизации кода без изменения поведения <a href="#lit3">[3]</a>. Для КОП это особенно важно, так как позволяет модифицировать поведение системы через изменение отдельных компонентов без затрагивания остальной архитектуры.</p>
                <p>Д. Кнут рассматривает программирование как форму выражения мысли <a href="#lit4">[4]</a>. В КОП, где компоненты должны быть переиспользуемыми и инкапсулированными, ясность их интерфейсов и поведения становится критическим фактором. Концепция чистого кода как выразительного средства полностью применима к описанию поведения компонентов и систем.</p>
                <p>Авторы «Паттернов проектирования» подчеркивают важность слабой связанности и высоко уровня абстракции <a href="#lit5">[5]</a>. Эти характеристики органично вписываются в КОП, где вместо иерархий классов применяются независимые модули, взаимодействующие через общие интерфейсы или события.</p>
                <p>К. Бек в рамках экстремального программирования настаивает на простоте реализации и приоритете тестируемости <a href="#lit6">[6]</a>. Для КОП, где поведение системы определяется взаимодействием множества компонентов, возможность изолированного тестирования каждого из них – необходимое условие надёжности.</p>
                <p>В «Программисте-прагматике» Томас и Хант подчёркивают значение повторного использования, отсутствия дублирования и локализации логики <a href="#lit7">[7]</a>. Эти требования совпадают с архитектурной философией КОП, в рамках которой компоненты должны быть автономными и легко заменяемыми.</p>
                <p>М. Физерс в книге «Работа с унаследованным кодом» описывает стратегии постепенного улучшения сложных систем без полной их переработки <a href="#lit8">[8]</a>. Это напрямую применимо к КОП, так как замена или модификация конкретных компонентов позволяет эволюционно адаптировать систему к новым требованиям.</p>
                <p>Анализ подходов признанных экспертов позволяет сделать вывод, что многие принципы чистого кода – читаемость, модульность, слабая связанность, тестируемость и минимализм – естественным образом интегрируются в компонентно-ориентированную архитектуру. Эти авторские идеи не только дополняют теоретическую базу КОП, но и обосновывают его эффективность с точки зрения инженерной практики. Таким образом, чистый код и КОП не просто совместимы – они взаимно усиливают друг друга в процессе построения гибких и сопровождаемых программных систем.</p>
            </section>

            <section>
                <h2>Когда используется Чистый Код</h2>
                <p>Здесь необходимо обратиться к парадигмам программирования и их предназначению. Если кратко, парадигмы программирования – это концепции, определяющие стиль написания кода в соответствии с определёнными принципами. Они помогают достичь оптимальных результатов в конкретных условиях. Многие парадигмы включают принципы и методологии, которые способствуют повышению эффективности разработки. Одним из ключевых преимуществ ООП является возможность структурировать программу с помощью классов, каждый из которых отвечает за свою область. Однако это может стать и недостатком: чрезмерное усложнение архитектуры ведёт к увеличению связей и затруднению сопровождения кода.</p>
                <p>Используя данный подход, важно учитывать последствия архитектурных решений. Следует задуматься о глубине иерархии: не приведёт ли она к чрезмерному усложнению структуры кода? Не сделает ли избыточная иерархия базовый класс хрупким? И, конечно, не приведёт ли слепое следование парадигме к ненужному усложнению кода?</p>
                <p>Важно понимать, что, когда разработчик пишет код, он пишет его не для компилятора, а для других людей. Когда возникает потребность в написании чистого кода? В первую очередь, каждый программист должен следить за тем, что он пишет. Когда он замечает проблему, он должен её решить. Роберт Мартин называет это «запахами кода» – ситуациями, когда разработчик интуитивно понимает, где может возникнуть проблема <a href="#lit1">[1]</a>.</p>
                <p>И здесь кроется главная особенность книги: «чистый код» – это не просто свод правил, а концепция развития кода. Это инструмент, который может как улучшить, так и ухудшить ситуацию, или философия, которая влияет на разработку, позволяя программисту использовать её не как цель, а как возможность улучшить состояние проекта.</p>
                <p>Если относиться к чистому коду не как к набору строгих правил, а как к идее о том, что код стоит чистить и улучшать, это позволит будущим разработчикам не тратить время на попытки разобраться в том, что делает этот код и зачем он нужен. Это, в свою очередь, облегчит развитие и поддержку кода. Именно поэтому в начале книги делается большой акцент на опыте других разработчиков. Большинство правил, приведённых в книге, используются на подсознательном уровне, когда программист понимает, с какими проблемами он может столкнуться, возвращаясь к коду, или где части кода могут быть слишком запутанными, как неопытное описание автора. Но опыт и стремление сделать свой код лучше – это лучшее лекарство от таких проблем. Анализ того, почему определённый кусок кода кажется непонятным или запутанным, позволяет взглянуть на код с другой стороны, как на искусство, порождающее понимание как в себе, так и в других людях. Именно к этому отсылает фраза из начала книги: «А как мне написать чистый код?» Бесполезно пытаться написать чистый код, если вы не знаете, что это такое! – Боб Мартин <a href="#lit1">[1]</a>.</p>
                <p>И самый большой плюс такого подхода – это простота разработки. Когда код начинает получаться простым, с понятной и проработанной структурой, не возникает вопросов о том, как получить доступ к переменной или где выделить функции для реализации определённой фичи так, чтобы это было органично. А когда приходится дополнять такой код, ранее разработанная структура начинает работать на разработчика, а не разработчик пытается втиснуть новый код в уже перегруженную систему.</p>
                <p>Поэтому многие находят отражение программирования в разных сферах: кто-то – в кулинарии, как Кнут, кто-то – в искусстве, как Мартин <a href="#lit4">[4]</a>. И действительно, чем больше разработчик рассматривает другие области, тем больше решений он может найти для своих задач, что побуждает к развитию и изучению нового.</p>
                <p>Ни архитектура, ни чистый код не требуют от нас совершенства – просто будьте честны и делайте все, что можете – Боб Мартин <a href="#lit1">[1]</a>.</p>
            </section>

            <section>
                <h2>Выводы</h2>
                <p>В данной статье проведён комплексный анализ понятия чистого кода, его характеристик и противоположности – грязного кода. Показано, что понятие чистого кода выходит за рамки формальных правил и является важным аспектом культуры программирования, ориентированным на повышение читаемости, сопровождаемости и адаптивности программных решений.</p>
                <p>Особое внимание уделено интеграции принципов чистого кода в компонентно-ориентированное программирование. Продемонстрировано, что КОП благодаря свойственным ему свойствам композиции, слабой связности и автономности компонентов, позволяет наиболее естественным образом применять идеи чистого кода в архитектуре программных систем.</p>
                <p>Отмечено, что эффективное использование принципов чистого кода требует осознанной адаптации к контексту конкретной задачи, а не механического следования установленным рекомендациям. Подход к чистому коду как к философии развития программного продукта позволяет достичь оптимального баланса между качеством архитектуры и практическими требованиями разработки.</p>
                <p>Перспективы дальнейших исследований связаны с изучением применения принципов чистого кода в других парадигмах программирования, а также с разработкой методик автоматизированного анализа качества кода в рамках КОП.</p>
            </section>


            <section id="lit_list">
                <h2>Литература</h2>
                <ol>
                    <li id="lit1">Мартин, Р. Чистый код: создание, анализ и рефакторинг. Библиотека программиста / Р. Мартин. - СПб.: Питер. 2019. – 452 с.</li>
                    <li id="lit2">Макконнелл, С. Совершенный код: мастер-класс по разработке программного обеспечения / С. Макконнелл. – СПб.: Питер, 2017. – 896 с.</li>
                    <li id="lit3">Фаулер, М. Рефакторинг. Улучшение проекта существующего кода/ М. Фаулер. Пер. с англ. - СПб: Символ-Плюс, 2003. - 432 с.</li>
                    <li id="lit4">Кнут, Д. Искусство программирования. Том 1: Основные алгоритмы / Д. Кнут. — М.: Вильямс, 2011. — 784 с.</li>
                    <li id="lit5">Гамма, Э. Приёмы объектно-ориентированного проектирования. Паттерны проектирования / Э. Гамма, Р. Хелм, Р. Джонсон, Влиссидзе. – СПб.: Питер, 2016. – 368 с.</li>
                    <li id="lit6">Бек, К. Экстремальное программирование: разработка через ценности / К. Бек. — СПб.: Питер, 2017. — 240 с.</li>
                    <li id="lit7">Томас, Д. Программист-прагматик: путь от подмастерья к мастеру / Д. Томас, Э. Хант. — СПб. Диалектика, 2020. — 352 с.</li>
                    <li id="lit8">Физерс М. Работа с унаследованным кодом: как улучшить старый код / М. Физерс. — М.: Вильямс, 2009. — 400 с.</li>
                    <li id="lit9">Heinman, G. T. Component-based software engineering : putting the pieces together / G. T. Heinman, W. T. Concill. - Boston : Addison-Wesley, 2001. – 818 с.</li>
                    <li id="lit10">Тепляков, С. Паттерны проектирования на платформе .NET / С. Тепляков. – СПБ: Питер, 2015. - 320 с.</li>
                    <li id="lit11">Эванс, Э. Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем / Э. Эванс. - Москва : 000 "И.Д. Вильямс", 2011. - 448 с.</li>
                    <li id="lit12">Медведев, В. И. NET компонентно ориентированное программирование / В. И. Медведев. - 2-е издание – Казань: Республиканский центр мониторинга качества образования, 2013. – 248 с.</li>
                    <li id="lit13">Кулямин, В. В. Компонентный подход в программировании/ В. В. Кулямин. - 2-е издание - М.: НОУ "Интуит" 2016. – 590 с.</li>
                </ol>
            </section>

            <section>
                <h2>Аннотация</h2>

                <div class="annotation">
                    <p><span class="name">Павлов М.Ю., Боднар А.В. Чистый код как концепция развития программного обеспечения: теория и применение в компонентно-ориентированном программировании.</span> Статья рассматривает понятие чистого кода и его роль в разработке ПО. Анализируются отличия чистого и "грязного" кода и их влияние на проектирование. Особое внимание уделено компонентно-ориентированному программированию как способу эффективного применения принципов чистого кода. Подход к чистому коду как к философии развития программного продукта позволяет достичь оптимального баланса между качеством архитектуры и практическими требованиями разработки.</p>
                </div>
                <p>Ключевые слова: чистый код, грязный код, компонентно-ориентированное программирование, композиция, архитектура ПО, сопровождаемость</p>
                
                <div class="annotation">
                    <p><span class="name">Pavlov M., Bodnar A. Clean Code as a Software Development Concept: Theory and Practice in Component-Oriented Programming.</span> The article examines the concept of clean code and its role in software development. It analyzes the differences between clean and "dirty" code and their impact on design. Special attention is given to component-oriented programming as an effective way to apply clean code principles. The approach to clean code as a software product development philosophy allows achieving an optimal balance between the quality of architecture and the practical requirements of development.</p>
                </div>
                <p>Keywords: clean code, dirty code, component-oriented programming, composition, software architecture, maintainability</p>

            </section>

        </main>
    </article>
</body>
</html>
